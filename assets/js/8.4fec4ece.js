(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{406:function(v,_,t){"use strict";t.r(_);var l=t(55),a=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),t("h2",{attrs:{id:"什么是数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是数据结构"}},[v._v("#")]),v._v(" 什么是数据结构")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("数据结构是"),t("code",[v._v("ADT")]),v._v(" (抽象数据类型)的物理实现")]),v._v(" "),t("ul",[t("li",[v._v("抽象：就是不具体的意思\n"),t("ul",[t("li",[v._v("与存放数据的机器无关")]),v._v(" "),t("li",[v._v("与数据存储的物理结构无关")]),v._v(" "),t("li",[v._v("与实现操作的算法和编程语言均无关")])])])])]),v._v(" "),t("li",[t("p",[v._v("数据结构是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最有效率的算法")])]),v._v(" "),t("li",[t("p",[v._v("数据对象在计算机中的组织方式")]),v._v(" "),t("ul",[t("li",[v._v("逻辑结构：比如一对一（线性结构）、一对多（树形结构）、多对多（图形结构）")]),v._v(" "),t("li",[v._v("物理结构：数组、链表等")])])]),v._v(" "),t("li",[t("p",[v._v("数据对象必定与一系列加在其上的操作相关联")])]),v._v(" "),t("li",[t("p",[v._v("完成这些操作所用的方法就是算法")])])]),v._v(" "),t("h2",{attrs:{id:"解决问题方法的效率和哪些因素有关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决问题方法的效率和哪些因素有关"}},[v._v("#")]),v._v(" 解决问题方法的效率和哪些因素有关")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("跟数据的组织方式有关")]),v._v(" "),t("ul",[t("li",[v._v("比如在书架上随意拜访图书和分类摆放，查找某本书的时候效率肯定不同")])])]),v._v(" "),t("li",[t("p",[v._v("跟空间的利用效率有关")]),v._v(" "),t("ul",[t("li",[v._v("比如循环输出0-100000，和递归输出0-100000，递归算法开辟的内存空间过大会导致程序崩溃")])])]),v._v(" "),t("li",[t("p",[v._v("跟算法的巧妙程度有关")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/GodX-18/pic-bed/raw/master/image-20220104154536886.png",alt:"image-20220104154536886"}})]),v._v(" "),t("ul",[t("li",[v._v("上图所示的两种算法，计算的速度要相差一个数量级，原因是计算机计算乘法的速度要比加法慢许多")])])])]),v._v(" "),t("h1",{attrs:{id:"算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[v._v("#")]),v._v(" 算法")]),v._v(" "),t("h2",{attrs:{id:"什么是算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是算法"}},[v._v("#")]),v._v(" 什么是算法")]),v._v(" "),t("ul",[t("li",[v._v("一个有限指令集")]),v._v(" "),t("li",[v._v("接受一些输入（参数）")]),v._v(" "),t("li",[v._v("产生输出")]),v._v(" "),t("li",[v._v("一定在有限步骤之后终止")]),v._v(" "),t("li",[v._v("每一条指令必须\n"),t("ul",[t("li",[v._v("有充分明确的目标，不可以有歧义")]),v._v(" "),t("li",[v._v("计算机能处理的范围之内")]),v._v(" "),t("li",[v._v("描述应不依赖于任何一种计算机语言以及具体的实现手段")])])])]),v._v(" "),t("h2",{attrs:{id:"什么是好的算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是好的算法"}},[v._v("#")]),v._v(" 什么是好的算法")]),v._v(" "),t("ul",[t("li",[v._v("判断一个算法的好坏主要从两个角度，简单来讲，一个算法占用的空间越小运行的越短它就是一个好的算法\n"),t("ul",[t("li",[v._v("空间复杂度-S❨n❩\n"),t("ul",[t("li",[v._v("根据算法写成的程序在执行时占用存储单元的长度")])])]),v._v(" "),t("li",[v._v("时间复杂度-T❨n❩\n"),t("ul",[t("li",[v._v("根据算法写成的程序在执行时耗费时间的长短")])])])])]),v._v(" "),t("li",[v._v("在分析一般算法的效率时，我们经常关注下面两种复杂度\n"),t("img",{attrs:{src:"https://gitee.com/GodX-18/pic-bed/raw/master/image-20220103100458160.png",alt:"image-20220103100458160"}}),v._v(" "),t("ul",[t("li",[v._v("最坏情况复杂度")]),v._v(" "),t("li",[v._v("平均复杂度")])])]),v._v(" "),t("li",[v._v("不同时间复杂度对应的时间增长曲线\n"),t("img",{attrs:{src:"https://gitee.com/GodX-18/pic-bed/raw/master/image-20220107113130255.png",alt:"image-20220107113130255"}})])])])}),[],!1,null,null,null);_.default=a.exports}}]);